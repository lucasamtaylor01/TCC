\chapter{Programas}  \label{app:apendice-lista-de-programas}

%%%%%%%%%%%%%%%%%%%% AMBIENTES

%----------- JULIA ---------------
\definecolor{codebg}{RGB}{247,248,250}
\definecolor{codenumber}{HTML}{7F8C8D}
\definecolor{codekw}{HTML}{005CC5}
\definecolor{codestr}{HTML}{032F62}
\definecolor{codecm}{HTML}{6A737D}
\definecolor{codetype}{HTML}{D73A49}
\definecolor{codemacro}{HTML}{8A2BE2}

% Julia para listings
\lstdefinelanguage{Julia}{
  alsoletter={@},
  morekeywords={
    abstract,break,catch,const,continue,do,else,elseif,end,export,false,finally,
    for,function,global,if,import,let,local,macro,module,mutable,primitive,
    quote,return,struct,true,try,using,where,while,begin
  },
  morekeywords=[2]{Int,Int8,Int16,Int32,Int64,UInt,UInt8,UInt16,UInt32,UInt64,
    Float16,Float32,Float64,Complex,ComplexF64,Bool,Char,String,Nothing,Any,
    Vector,Matrix,Dict,Tuple,Union,SubArray,AbstractArray,Range},
  morekeywords=[3]{@time,@views,@inbounds,@simd,@threads,@btime,@benchmark,
    @show,@assert,@inline,@code_warntype,@test},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
}

% Estilo base
\lstdefinestyle{jlstyle}{
  language=Julia,
  backgroundcolor=\color{codebg},
  basicstyle=\ttfamily\small,
  numbers=left,
  numberstyle=\scriptsize\color{codenumber},
  numbersep=8pt,
  showstringspaces=false,
  tabsize=2,
  columns=fullflexible,
  keepspaces=true,
  breaklines=true,
  frame=single,
  rulecolor=\color{codebg},
  keywordstyle=\bfseries\color{codekw},
  keywordstyle=[2]\color{codetype},
  keywordstyle=[3]\color{codemacro},
  commentstyle=\itshape\color{codecm},
  stringstyle=\color{codestr},
  upquote=true,
  % Alguns símbolos/Unicode comuns em Julia
  literate=
    {→}{{$\to$}}1 {←}{{$\leftarrow$}}1
    {≤}{{$\le$}}1 {≥}{{$\ge$}}1
    {α}{{$\alpha$}}1 {β}{{$\beta$}}1 {γ}{{$\gamma$}}1
    {π}{{$\pi$}}1 {√}{{$\sqrt{\phantom{x}}$}}1
    {λ}{{$\lambda$}}1 {ϵ}{{$\varepsilon$}}1
    {σ}{{$\sigma$}}1 {²}{{$^2$}}1
    {Δ}{{$\Delta$}}1
}

% Ambiente e macro inline
\lstnewenvironment{juliacode}[1][]%
  {\lstset{style=jlstyle}\lstset{#1}}{}

\newcommand{\jinline}[1]{\lstinline[style=jlstyle]!#1!}

%---------------- PYTHON
% Python para listings
\lstdefinelanguage{Python}{
  morekeywords={
    and,as,assert,break,class,continue,def,del,elif,else,except,False,finally,
    for,from,global,if,import,in,is,lambda,None,nonlocal,not,or,pass,raise,
    return,True,try,while,with,yield,match,case,async,await
  },
  morekeywords=[2]{int,float,bool,str,bytes,bytearray,complex,list,tuple,set,dict,
    range,object,type,classmethod,staticmethod,property,Exception,BaseException},
  morekeywords=[3]{@dataclass,@property,@staticmethod,@classmethod,@abstractmethod,
    @lru_cache,@cache,@jit},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]',
}

% Estilo base para Python (análogo ao jlstyle)
\lstdefinestyle{pystyle}{
  language=Python,
  backgroundcolor=\color{codebg},
  basicstyle=\ttfamily\small,
  numbers=left,
  numberstyle=\scriptsize\color{codenumber},
  numbersep=8pt,
  showstringspaces=false,
  tabsize=4,
  columns=fullflexible,
  keepspaces=true,
  breaklines=true,
  frame=single,
  rulecolor=\color{codebg},
  keywordstyle=\bfseries\color{codekw},
  keywordstyle=[2]\color{codetype},
  keywordstyle=[3]\color{codemacro},
  commentstyle=\itshape\color{codecm},
  stringstyle=\color{codestr},
  upquote=true,
  literate=
    {→}{{$\to$}}1 {←}{{$\leftarrow$}}1
    {≤}{{$\le$}}1 {≥}{{$\ge$}}1
    {α}{{$\alpha$}}1 {β}{{$\beta$}}1 {γ}{{$\gamma$}}1
    {π}{{$\pi$}}1 {√}{{$\sqrt{\phantom{x}}$}}1
    {λ}{{$\lambda$}}1 {ϵ}{{$\varepsilon$}}1
    {σ}{{$\sigma$}}1 {²}{{$^2$}}1
    {Δ}{{$\Delta$}}1
}

% Ambiente pronto para uso: \begin{pycode}[<opcionais do listings>] ... \end{pycode}
\lstnewenvironment{pycode}[1][]{\lstset{style=pystyle,#1}}{}

% Comando para inline code em Python
\newcommand{\pyinline}[1]{\lstinline[style=pystyle]{#1}}

%%%%%%%%%%%%%%%%%%%% CONTEÚDO

\section{Lorenz 80 determinístico}\label{appsec:lorenz80-det}
\begin{pycode}[caption={Simulação do modelo L80 PE, QG e BE}, label={lst:sim-l80}]
    import numpy as np
    from scipy.integrate import solve_ivp
    import pandas as pd
    from phi import Phi
    from parameters import a, b, c, h, f, nu_0, kappa_0, g_0

    TIMESCALE_FACTOR = 8.0
    
    def cyc(i):
        return i, (i + 1) % 3, (i + 2) % 3
    
    def pe_model(t, u):
        x = u[0:3]
        y = u[3:6]
        z = u[6:9]
        dx = np.zeros(3)
        dy = np.zeros(3)
        dz = np.zeros(3)
    
        for i in range(3):
            i_, j, k = cyc(i)
            dx[i] = (
                a[i] * b[i] * x[j] * x[k]
                - c * (a[i] - a[k]) * x[j] * y[k]
                + c * (a[i] - a[j]) * y[j] * x[k]
                - 2 * c**2 * y[j] * y[k]
                - nu_0 * (a[i] ** 2) * x[i]
                + a[i] * y[i]
                - a[i] * z[i]
            ) / a[i]
            dy[i] = (
                -a[k] * b[k] * x[j] * y[k]
                - a[j] * b[j] * y[j] * x[k]
                + c * (a[k] - a[j]) * y[j] * y[k]
                - a[i] * x[i]
                - nu_0 * (a[i] ** 2) * y[i]
            ) / a[i]
            dz[i] = (
                -b[k] * x[j] * (z[k] - h[k])
                - b[j] * (z[j] - h[j]) * x[k]
                + c * y[j] * (z[k] - h[k])
                - c * (z[j] - h[j]) * y[k]
                + g_0 * a[i] * x[i]
                - kappa_0 * a[i] * z[i]
                + f[i]
            )
        return np.concatenate([dx, dy, dz])
    
    def pe_simulate(x0, y0, z0, days):
        initial_u = np.concatenate([x0, y0, z0])
        t_final = days * TIMESCALE_FACTOR
        t_span = (0, t_final)
    
        print("Iniciando integracao numerica para o modelo PE...")
        sol = solve_ivp(
            pe_model, t_span, initial_u, method="RK45", atol=1e-8, rtol=1e-6
        )
        print("Aguarde...")
    
        t = sol.t / TIMESCALE_FACTOR
        x, y, z = sol.y[0:3].T, sol.y[3:6].T, sol.y[6:9].T
    
        df = pd.DataFrame({
            "time": t,
            "x1": x[:, 0], "x2": x[:, 1], "x3": x[:, 2],
            "y1": y[:, 0], "y2": y[:, 1], "y3": y[:, 2],
            "z1": z[:, 0], "z2": z[:, 1], "z3": z[:, 2],
        })
        return df
    
    def be_model(tau, y, phi_vec):
        dydt = np.zeros(3, dtype=float)
        for i in range(3):
            i_, j, k = cyc(i)
            dydt[i] = (
                - (a[k] * b[k] / a[i]) * phi_vec[j] * y[k]
                - (a[j] * b[j] / a[i]) * y[j] * phi_vec[k]
                + (c * (a[k] - a[j]) / a[i]) * y[j] * y[k]
                - phi_vec[i]
                - nu_0 * a[i] * y[i]
            )
        return dydt
    
    def qg_model(t, y):
        dy = np.zeros(3, dtype=float)
        for i in range(3):
            _, j, k = cyc(i)
            dy[i] = (
                g_0 * c * (a[k] - a[j]) * y[j] * y[k]
                - a[i] * (a[i] * g_0 * nu_0 + kappa_0) * y[i]
                - c * h[k] * y[j]
                + c * h[j] * y[k]
                + f[i]
            ) / (a[i] * g_0 + 1.0)
        return dy
    
    def simulate_model(model_func, y0, days, model_name, dt=0.001, model_args=()):
        t_final = days * TIMESCALE_FACTOR
        t_span = (0, t_final)
        t_eval = np.arange(0, t_final + dt, dt)
    
        print(f"Iniciando integracao numerica para o modelo {model_name}...")
        sol = solve_ivp(
            model_func, t_span, y0, t_eval=t_eval, args=model_args,
            method="RK45", atol=1e-8, rtol=1e-6
        )
        print("Aguarde...")
    
        t = sol.t / TIMESCALE_FACTOR
        y = sol.y
    
        df = pd.DataFrame({
            "time": t,
            "y1": y[0], "y2": y[1], "y3": y[2],
        })
        return df
    
    def be_simulate(y0, days):
        phi_vec = Phi(y0)
        return simulate_model(be_model, y0, days, "BE", model_args=(phi_vec,))
    
    def qg_simulate(y0, days):
        return simulate_model(qg_model, y0, days, "QG")

\end{pycode}

\section{Simulação de preço de uma ação de mercado}\label{appsec:acoes}
\begin{juliacode}[caption={Simulação do preço de uma ação no mercado}, label={lst:stock-market-sde}]
    using DifferentialEquations, DataFrames, CSV
    import StochasticDiffEq as SDE
    
    f(u,p,t) = mu*u
    g(u,p,t)= sigma
    dt = 1/(365*24)
    mu = 0.05
    sigma = 1.0
    tspan = (0.0, 1.0)
    u0= 12
    prob = SDEProblem(f,g,u0,tspan, seed=13865062)
    sol = SDE.solve(prob, EM(), dt = dt);
    
    df = DataFrame(t = sol.t, x = sol.u)
    outfile = joinpath(@__DIR__, "stockmarket.csv")
    CSV.write(outfile, df)
    println("Dados salvos em: $outfile")
\end{juliacode}

\section{\textit{Fast Chaotic Noise}}\label{appsec:fcn}
\begin{pycode}[caption={Simulação do modelo determinístico}, label={lst:fcn-deterministico}]
    import numpy as np
    import pandas as pd
    from scipy.integrate import solve_ivp
    from pathlib import Path
    import time
    
    eps = 0.1
    lam = 1.0
    
    def rhs(t, u):
        x, y1, y2, y3 = u
        dx = x - x**3 + (lam/eps) * y2
        dy1 = (10 / eps**2) * (y2 - y1)
        dy2 = (1 / eps**2) * (28*y1 - y2 - y1*y3)
        dy3 = (1 / eps**2) * (y1*y2 - (8/3)*y3)
        return [dx, dy1, dy2, dy3]
    
    
    p = 2.0  
    rtol = 1e-3 * eps**p
    atol = 1e-6 * eps**p
    
    print(f"Usando rtol={rtol:.2e}, atol={atol:.2e}")
    
    t0, tf = 0.0, 100.0
    x0 = 0.1
    y0 = [x0, 1e-2, 1e-2, 1e-2]
    t_eval = np.arange(t0, tf, 1e-3)
    
    print("Iniciando integracao numerica...")
    
    start_time = time.time()
    sol = solve_ivp(rhs, (t0, tf), y0, method="RK45",t_eval=t_eval, rtol=rtol, atol=atol)
    end_time = time.time()
    
    execution_time = end_time - start_time
    
    x_vals = sol.y[0]
    y2_vals = sol.y[2]
    
    BASE = Path(__file__).resolve().parent if "__file__" in globals() else Path(".")
    DATADIR = BASE / "data"
    DATADIR.mkdir(parents=True, exist_ok=True)
    eps_str = str(eps).replace(".", "")
    out_file = DATADIR / f"deterministico_{eps_str}.csv"
    
    print("\nSalvando dados...")
    df = pd.DataFrame({"t": sol.t, "y2": y2_vals, "x": x_vals})
    with open(out_file, 'w') as f:
        f.write(f'# eps={eps}, rtol={rtol:.2e}, atol={atol:.2e}, tempo={execution_time:.2f}s\n')
        df.to_csv(f, index=False)
    
    print(f"Dados salvos em: {out_file}")
\end{pycode}

\begin{pycode}[caption={Cálculo do sigma}, label={lst:fcn-sigma}]
    import numpy as np
    import pandas as pd
    import os
    
    def sigma_from_y2(y2, dt, lam=1.0):
        y = y2 - np.mean(y2)
        n = len(y)
        nfft = n
        fy = np.fft.rfft(y, n=nfft)
        ac = np.fft.irfft(fy * np.conj(fy), n=nfft)[:n] / np.arange(n, 0, -1)
        sigma2 = abs(2 * lam**2 * dt * np.sum(ac))
        return np.sqrt(max(sigma2, 0.0))
    
    
    csv_path = os.path.join(os.path.dirname(__file__), "data", "deterministico_001.csv")
    df = pd.read_csv(csv_path, comment="#")
    dt = df["t"][1] - df["t"][0]
    sigma = sigma_from_y2(df["y2"].to_numpy(), dt)
    print("sigma", sigma)
\end{pycode}

\begin{juliacode}[caption={Simulação do preço de uma ação no mercado}, label={lst:stock-market-sde}]
    using DifferentialEquations, DataFrames, CSV, Random
    eps = 0.1
    # Valores calculados previamente
    if eps == 0.5
        sigma = 242.69367736299662
    elseif eps == 0.2
        sigma = 205.05745681770404
    elseif eps == 0.1
        sigma = 142.6677313864854
    elseif eps == 0.01
        sigma = 5.754046294922591
    else
        error("Valor de epsilon invalido. Use 0.5, 0.2 ou 0.1.")
        exit()
    end
    x0 = 0.1
    tspan = (0.0, 100.0)
    
    f1(X, p, t) = X - X^3
    f2(X, p, t) = p
    
    prob = SDEProblem(f1, f2, x0, tspan, sigma)
    solucao_estocastico = solve(prob, EM(), dt = 1e-3, seed = 13865062)
    df = DataFrame(t = solucao_estocastico.t, x = solucao_estocastico.u)
    cd(@__DIR__)
    
    if eps == 0.5
        eps_suffix = "_05"
    elseif eps == 0.2
        eps_suffix = "_02"
    elseif eps == 0.1
        eps_suffix = "_01"
    elseif eps == 0.01
        eps_suffix = "_001"
    end
    
    filename = "data/estocastico$(eps_suffix).csv"
    CSV.write(filename, df)
    println("Dados estocasticos salvos em: $filename")
\end{juliacode}