\chapter{Programas}  \label{app:apendice-lista-de-programas}

%%%%%%%%%%%%%%%%%%%% AMBIENTES

%----------- JULIA ---------------
\definecolor{codebg}{RGB}{247,248,250}
\definecolor{codenumber}{HTML}{7F8C8D}
\definecolor{codekw}{HTML}{005CC5}
\definecolor{codestr}{HTML}{032F62}
\definecolor{codecm}{HTML}{6A737D}
\definecolor{codetype}{HTML}{D73A49}
\definecolor{codemacro}{HTML}{8A2BE2}

% Julia para listings
\lstdefinelanguage{Julia}{
  alsoletter={@},
  morekeywords={
    abstract,break,catch,const,continue,do,else,elseif,end,export,false,finally,
    for,function,global,if,import,let,local,macro,module,mutable,primitive,
    quote,return,struct,true,try,using,where,while,begin
  },
  morekeywords=[2]{Int,Int8,Int16,Int32,Int64,UInt,UInt8,UInt16,UInt32,UInt64,
    Float16,Float32,Float64,Complex,ComplexF64,Bool,Char,String,Nothing,Any,
    Vector,Matrix,Dict,Tuple,Union,SubArray,AbstractArray,Range},
  morekeywords=[3]{@time,@views,@inbounds,@simd,@threads,@btime,@benchmark,
    @show,@assert,@inline,@code_warntype,@test},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
}

% Estilo base
\lstdefinestyle{jlstyle}{
  language=Julia,
  backgroundcolor=\color{codebg},
  basicstyle=\ttfamily\small,
  numbers=left,
  numberstyle=\scriptsize\color{codenumber},
  numbersep=8pt,
  showstringspaces=false,
  tabsize=2,
  columns=fullflexible,
  keepspaces=true,
  breaklines=true,
  frame=single,
  rulecolor=\color{codebg},
  keywordstyle=\bfseries\color{codekw},
  keywordstyle=[2]\color{codetype},
  keywordstyle=[3]\color{codemacro},
  commentstyle=\itshape\color{codecm},
  stringstyle=\color{codestr},
  upquote=true,
  % Alguns símbolos/Unicode comuns em Julia
  literate=
    {→}{{$\to$}}1 {←}{{$\leftarrow$}}1
    {≤}{{$\le$}}1 {≥}{{$\ge$}}1
    {α}{{$\alpha$}}1 {β}{{$\beta$}}1 {γ}{{$\gamma$}}1
    {π}{{$\pi$}}1 {√}{{$\sqrt{\phantom{x}}$}}1
    {λ}{{$\lambda$}}1 {ϵ}{{$\varepsilon$}}1
    {σ}{{$\sigma$}}1 {²}{{$^2$}}1
    {Δ}{{$\Delta$}}1
}

% Ambiente e macro inline
\lstnewenvironment{juliacode}[1][]%
  {\lstset{style=jlstyle}\lstset{#1}}{}

\newcommand{\jinline}[1]{\lstinline[style=jlstyle]!#1!}

%---------------- PYTHON
% Python para listings
\lstdefinelanguage{Python}{
  morekeywords={
    and,as,assert,break,class,continue,def,del,elif,else,except,False,finally,
    for,from,global,if,import,in,is,lambda,None,nonlocal,not,or,pass,raise,
    return,True,try,while,with,yield,match,case,async,await
  },
  morekeywords=[2]{int,float,bool,str,bytes,bytearray,complex,list,tuple,set,dict,
    range,object,type,classmethod,staticmethod,property,Exception,BaseException},
  morekeywords=[3]{@dataclass,@property,@staticmethod,@classmethod,@abstractmethod,
    @lru_cache,@cache,@jit},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]',
}

% Estilo base para Python (análogo ao jlstyle)
\lstdefinestyle{pystyle}{
  language=Python,
  backgroundcolor=\color{codebg},
  basicstyle=\ttfamily\small,
  numbers=left,
  numberstyle=\scriptsize\color{codenumber},
  numbersep=8pt,
  showstringspaces=false,
  tabsize=4,
  columns=fullflexible,
  keepspaces=true,
  breaklines=true,
  frame=single,
  rulecolor=\color{codebg},
  keywordstyle=\bfseries\color{codekw},
  keywordstyle=[2]\color{codetype},
  keywordstyle=[3]\color{codemacro},
  commentstyle=\itshape\color{codecm},
  stringstyle=\color{codestr},
  upquote=true,
  literate=
    {→}{{$\to$}}1 {←}{{$\leftarrow$}}1
    {≤}{{$\le$}}1 {≥}{{$\ge$}}1
    {α}{{$\alpha$}}1 {β}{{$\beta$}}1 {γ}{{$\gamma$}}1
    {π}{{$\pi$}}1 {√}{{$\sqrt{\phantom{x}}$}}1
    {λ}{{$\lambda$}}1 {ϵ}{{$\varepsilon$}}1
    {σ}{{$\sigma$}}1 {²}{{$^2$}}1
    {Δ}{{$\Delta$}}1
}

% Ambiente pronto para uso: \begin{pycode}[<opcionais do listings>] ... \end{pycode}
\lstnewenvironment{pycode}[1][]{\lstset{style=pystyle,#1}}{}

% Comando para inline code em Python
\newcommand{\pyinline}[1]{\lstinline[style=pystyle]{#1}}

%%%%%%%%%%%%%%%%%%%% CONTEÚDO

\section{Código do modelo Lorenz 80 determinístico}


\begin{pycode}[caption={Simulação do modelo Lorenz 80 determinístico}, label={prog:lorenz80}]
import numpy as np
from scipy.integrate import solve_ivp
import pandas as pd
from pathlib import Path

a = [1, 1, 3]
b = [
    0.5 * (a[0] - a[1] - a[2]),
    0.5 * (a[1] - a[2] - a[0]),
    0.5 * (a[2] - a[0] - a[1]),
]
c = np.sqrt(b[0]*b[1] + b[1]*b[2] + b[2]*b[0])

h = [-1, 0, 0]
f = [0.3027, 0, 0]
g_0 = 8
kappa_0 = 1 / 48
nu_0 = kappa_0

def pe_model(t, u):
    x = u[0:3]
    y = u[3:6]
    z = u[6:9]
    dx = np.zeros(3)
    dy = np.zeros(3)
    dz = np.zeros(3)
    for i in range(3):
        j = (i + 1) % 3
        k = (i + 2) % 3
        dx[i] = (
            a[i] * b[i] * x[j] * x[k]
            - c * (a[i] - a[k]) * x[j] * y[k]
            + c * (a[i] - a[j]) * y[j] * x[k]
            - 2 * c**2 * y[j] * y[k]
            - nu_0 * (a[i] ** 2) * x[i]
            + a[i] * y[i]
            - a[i] * z[i]
        ) / a[i]
        dy[i] = (
            -a[k] * b[k] * x[j] * y[k]
            - a[j] * b[j] * y[j] * x[k]
            + c * (a[k] - a[j]) * y[j] * y[k]
            - a[i] * x[i]
            - nu_0 * (a[i] ** 2) * y[i]
        ) / a[i]
        dz[i] = (
            -b[k] * x[j] * (z[k] - h[k])
            - b[j] * (z[j] - h[j]) * x[k]
            + c * y[j] * (z[k] - h[k])
            - c * (z[j] - h[j]) * y[k]
            + g_0 * a[i] * x[i]
            - kappa_0 * a[i] * z[i]
            + f[i]
        )
    return np.concatenate([dx, dy, dz])

def simulate(x0, y0, z0, days): 
    initial_u = np.concatenate([x0, y0, z0])
    t_final = days * 8
    t_span = (0, t_final)
    sol = solve_ivp(pe_model, t_span, initial_u, method="RK45", atol=1e-8, rtol=1e-6)
    return sol.t / 8, sol.y[:3].T, sol.y[3:6].T, sol.y[6:].T


days = 400

# HARDLEY
y1 = f[0]/(a[0]*nu_0*(1+a[0]*g_0))
x1 = -nu_0*a[0]*y1
z1 = y1


x0 = [x1, 0, 0]
y0 = [y1, -(10 ** (-5)), 0]
z0 = [z1, 10 ** (-5), 0]

"""
# DEFAULT

x0 = [0.1,0.1,0.1]
y0 = [0.1,0.1,0.1]
z0 = [0.1,0.1,0.1]
"""

t, x, y, z = simulate(x0, y0, z0, days)

x = np.asarray(x)
y = np.asarray(y)
z = np.asarray(z)
t = np.squeeze(np.asarray(t))

df = pd.DataFrame(
    {
        "time": t,
        "x1": x[:, 0],
        "x2": x[:, 1],
        "x3": x[:, 2],
        "y1": y[:, 0],
        "y2": y[:, 1],
        "y3": y[:, 2],
        "z1": z[:, 0],
        "z2": z[:, 1],
        "z3": z[:, 2],
    }
)

BASE = Path(__file__).resolve().parent
DATADIR = BASE / "data"
DATADIR.mkdir(parents=True, exist_ok=True)
out_file = DATADIR / "f03027d400_cond_hardley.csv"
df.to_csv(out_file, index=False)

print(f"CSV salvo em: {out_file}")
\end{pycode}

\section{Simulação de mercado de ações}
\begin{juliacode}[caption={Simulação da evolução de preço de mercado de ações}, label={prog:mercado-de-acoes}]
using DifferentialEquations, DataFrames, CSV
import StochasticDiffEq as SDE

f(u,p,t) = mu*u
g(u,p,t)= sigma
dt = 1/(365*24)
mu = 0.05
sigma = 1.0
tspan = (0.0, 1.0)
u0= 12
prob = SDEProblem(f,g,u0,tspan, seed=13865062)
sol = SDE.solve(prob, EM(), dt = dt);

df = DataFrame(t = sol.t, x = sol.u)
cd(@__DIR__)  
CSV.write("data/stock_market.csv", df)
println("Dados salvos em: data/stock_market.csv")
\end{juliacode}
\section{Ruído caótico rápido}
\begin{pycode}[caption={Simulação do modelo determinístico}, label={prog:ruido_caotico_det}]
import numpy as np
import pandas as pd
from scipy.integrate import solve_ivp
from pathlib import Path

eps = 0.01
lam = 1.0

def rhs(t, u):
    x, y1, y2, y3 = u
    dx = x - x**3 + (lam/eps) * y2
    dy1 = (10 / eps**2) * (y2 - y1)
    dy2 = (1 / eps**2) * (28*y1 - y2 - y1*y3)
    dy3 = (1 / eps**2) * (y1*y2 - (8/3)*y3)
    return [dx, dy1, dy2, dy3]

t0, tf = 0.0, 25.0
x0 = 0.1
y0_vals = [1e-2, 1e-2, 1e-2]
y0 = [x0] + y0_vals
t_eval = np.arange(t0, tf, 1e-3)

sol = solve_ivp(rhs, (t0, tf), y0, method="RK45", t_eval=t_eval, rtol=1e-4, atol=1e-6)

x_vals = sol.y[0]
y2_vals = sol.y[2]

BASE = Path(__file__).resolve().parent if "__file__" in globals() else Path(".")
DATADIR = BASE / "data"
DATADIR.mkdir(parents=True, exist_ok=True)

df = pd.DataFrame({"t": sol.t, "y2": y2_vals, "x": x_vals})
df.to_csv(DATADIR / "deterministico.csv", index=False)
print(f"Dados salvos em: {DATADIR / 'deterministico.csv'}")
\end{pycode}
\begin{pycode}[caption={Cálculo do sigma}, label={prog:ruido_caotico_sigma}]
import numpy as np
import pandas as pd
import os

def sigma_from_y2(y2, dt, lam=1.0):
    y = y2 - np.mean(y2)
    n = len(y)
    nfft = n
    fy = np.fft.rfft(y, n=nfft)
    ac = np.fft.irfft(fy * np.conj(fy), n=nfft)[:n] / np.arange(n, 0, -1)
    sigma2 = abs(2 * lam**2 * dt * np.sum(ac))
    return np.sqrt(max(sigma2, 0.0))


csv_path = os.path.join(os.path.dirname(__file__), "data", "deterministico.csv")
df = pd.read_csv(csv_path)
dt = df["t"][1] - df["t"][0]
sigma = sigma_from_y2(df["y2"].to_numpy(), dt)
print("σ =", sigma)

\end{pycode}

\begin{juliacode}[caption={Simulação sistema estocástico}, label={prog:ruido_caotico_est}]
using DifferentialEquations, Plots, DataFrames, CSV, Random


sigma = 7.879942813768798
x0 = 0.1
tspan = (0.0, 25.0)

f1(X, p, t) = X - X^3
f2(X, p, t) = p

prob = SDEProblem(f1, f2, x0, tspan, sigma)
solucao_estocastico = solve(prob, EM(), dt = 1e-3, seed = 13865062)

df = DataFrame(t = solucao_estocastico.t, x = solucao_estocastico.u)
cd(@__DIR__)  
CSV.write("data/estocastico.csv", df)
println("Dados estocasticos salvos em: data/estocastico.csv")

\end{juliacode}

